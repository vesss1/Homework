# 41343127
---
作業一 

## **Ackermann Function(遞迴方式)**

**解題說明**

本程式利用遞迴方式實作 Ackermann 函數：  
- 若 x = 0，回傳 y + 1。  
- 若 y = 0，回傳 A(x−1, 1)。  
- 否則回傳 A(x−1, A(x, y−1))。 

Ackermann 函數是經典的遞迴範例，能展現遞迴的深度與函數呼叫堆疊概念。  

---

### 程式設計  
```cpp
#include <iostream>
using namespace std;

int A(int x, int y) {
    if (x == 0)
        return y + 1;
    else if (y == 0)
        return A(x - 1, 1);
    else
        return A(x - 1, A(x, y - 1));
}

int main() {
    int x, y;
    cout << "Enter x and y: ";
    cin >> x >> y;
    cout << "Ackermann(" << x << "," << y << ") = " << A(x, y) << endl;
    return 0;
}
```

| 輸入 (x, y) | 輸出結果 |
| --------- | ---- |
| 0, 0      | 1    |
| 1, 2      | 4    |
| 2, 2      | 7    |

---
結論

本程式可正確計算 Ackermann 函數結果，但當 x 或 y 較大時會導致遞迴過深，可能造成堆疊溢位。

---
心得與問題

這題剛開始看起來不難，但實際在跑的時候才發現 Ackermann 函數的遞迴層數非常深，一不小心就會超出系統限制。透過這次練習，我比較清楚地理解遞迴的執行順序，也學會用堆疊去模擬遞迴的過程。雖然程式不長，但要讓結果正確需要仔細追蹤變數的變化。整體來說，這題讓我更能體會到遞迴雖然簡潔，但效能和記憶體消耗都要特別注意。

**非遞迴方式**
---
**解題說明**

本程式以手動模擬堆疊的方式實作 Ackermann 函數，避免遞迴呼叫。
使用兩個陣列 sx[]、sy[] 模擬函數堆疊過程。

---
**解題策略**

這題的目標是把 Ackermann 函數改成「非遞迴」寫法。因為 Ackermann 函數本身是高度遞迴的，遞迴層數很深，所以直接呼叫會導致系統堆疊溢位。要解決這個問題，可以用「模擬堆疊」的方式來重現遞迴行為。
基本想法是利用兩個陣列（sx[] 和 sy[]）來存放每次呼叫的 x、y 值，並用變數 top 來當作堆疊頂端的指標。每次根據條件（x == 0、y == 0 或一般情況）決定要不要壓入新狀態或回傳結果。
另外在遞迴結束後，要小心處理「回傳階段」，讓前一層呼叫能拿到內層結果。這樣就能在不使用系統遞迴的情況下，完成同樣的運算流程。

## 輸入階段

1. 使用者輸入兩個整數 **m**、**n**，代表 Ackermann 函數的參數。  

2. **初始化堆疊**  
   - 宣告陣列 `stackM[1000]` 來模擬系統堆疊。  
   - 設定變數 `top = -1` 作為堆疊頂端指標。  
   - 將初始值 `m` 推入堆疊。  

3. **迴圈處理（模擬遞迴）**  
   - 當堆疊不為空（`top >= 0`）時：  
     取出堆疊最上層的 `m` 值。  

---

## 測試策略

1. 從小值測試（`m = 0`, `n = 0`）開始，確保基礎情況正確。  
2. 逐步增加 `m` 和 `n`，驗證程式正確性與堆疊使用。  
3. 記錄結果，與教學公式計算結果比對。  

---
程式實作
---
```cpp
#include <iostream>
using namespace std;

int A(int x, int y) {
    int sx[10000], sy[10000]; // 模擬堆疊
    int top = 0;
    sx[top] = x;
    sy[top] = y;

    while (top >= 0) {
        x = sx[top];
        y = sy[top];
        top--;

        if (x == 0) {
            y = y + 1;
        } 
        else if (y == 0) {
            top++;
            sx[top] = x - 1;
            sy[top] = 1;
            continue;
        } 
        else {
            top++;
            sx[top] = x - 1;
            sy[top] = -1; // 標記等內層結果
            top++;
            sx[top] = x;
            sy[top] = y - 1;
            continue;
        }

        // 模擬回傳階段
        while (top >= 0 && sy[top] == -1) {
            x = sx[top];
            top--;
            top++;
            sx[top] = x;
            sy[top] = y;
            break;
        }
    }
    return y;
}

int main() {
    int x, y;
    cout << "Enter x and y: ";
    cin >> x >> y;
    cout << "Ackermann(" << x << "," << y << ") = " << A(x, y) << endl;
    return 0;
}
```

| 輸入 (x, y) | 輸出結果 |
| --------- | ---- |
| 0, 0      | 1    |
| 1, 2      | 4    |
| 2, 2      | 7    |

---
**結論**

以堆疊模擬取代遞迴可避免系統堆疊溢位問題，但程式碼較複雜，需小心處理回傳邏輯。

## 心得與問題

透過這一題，我更清楚地理解了遞迴在程式執行時的實際運作方式。原本以為只要用 return 呼叫就能簡單處理，但在自己嘗試改成「非遞迴」版本時，才發現系統其實在背後幫我們維護了一個堆疊。這次用陣列自己模擬堆疊的過程，讓我更能體會到每一層函數呼叫是如何被壓入、彈出，也明白為什麼 Ackermann 函數那麼容易造成堆疊溢位。
雖然一開始寫的時候常常卡在變數回傳錯誤或堆疊沒清乾淨的問題，但多次測試後就慢慢抓到邏輯。整體來說，這題讓我更有耐心去追蹤程式的細節，也學會如何用資料結構的概念去解決遞迴造成的效能問題。

# 作業一 之Powerset
---
## 解題說明

本程式以遞迴方式輸出集合的所有子集合（Power Set）。
原理：對每個元素，都有「選或不選」兩種情況，最終形成所有可能組合。

### 解題策略
對每個元素做二元決策：

- 不選擇 → 遞迴下一個元素

- 選擇 → 將元素加入子集合，遞迴下一個元素

- 遞迴終止條件： 當處理完最後一個元素，印出當前子集合

程式設計
---
```cpp
#include <iostream>
#include <vector>
using namespace std;

void powerSet(vector<char> z, vector<char> cur, int x) {
    if (x == z.size()) {
        cout << "{";
        for (int i = 0; i < cur.size(); i++) {
            cout << cur[i];
            if (i < cur.size() - 1) cout << ",";
        }
        cout << "}" << endl;
        return;
    }

    // 不包含 z[x]
    powerSet(z, cur, x + 1);
    // 包含 z[x]
    cur.push_back(z[x]);
    powerSet(z, cur, x + 1);
}

int main() {
    vector<char> z = {'a', 'b', 'c'};
    vector<char> cur;
    powerSet(z, cur, 0);
    return 0;
}
```
### 測試結果

| 測試輸入    | 輸出結果                                            |
| ------- | ----------------------------------------------- |
| {a,b,c} | {}, {c}, {b}, {b,c}, {a}, {a,c}, {a,b}, {a,b,c} |

### 程式邏輯
每個元素有兩種選擇：

1.不加入子集合

2.加入子集合

使用遞迴逐層選擇每個元素，直到處理完所有元素。


---
結論

此程式能完整輸出所有子集合，展示遞迴在組合生成中的應用。

---
## 心得與問題

這題主要是利用遞迴產生所有可能的子集合。  
剛開始在想的時候有點混亂，不太清楚遞迴要怎麼同時處理「包含」和「不包含」的情況，  
但實際寫出來並跑過幾次後，才慢慢理解每一層呼叫其實就是在做一次選擇。  
這題雖然不長，但讓我更能掌握遞迴的思考方式，  
也學會用簡單的程式邏輯去處理組合問題。  

## 申論及開發報告

這次作業主要是用遞迴的方式來產生一個集合的所有子集合 (Power Set)。  
原理是每個元素都有「要」或「不要」兩種選擇，用遞迴去模擬就能得到所有組合。  

在寫程式的時候，我先判斷遞迴的結束條件，當處理到最後一個元素時就把目前的組合印出。  
接著分別呼叫「不加入」和「加入」當前元素的情況，這樣就能列出所有結果。  

測試 `{a, b, c}` 時，輸出結果是 `{}`, `{c}`, `{b}`, `{b,c}`, `{a}`, `{a,c}`, `{a,b}`, `{a,b,c}`，符合預期。  

這次練習讓我更了解遞迴的運作方式，也學到要小心控制終止條件，不然容易造成無限遞迴。  
